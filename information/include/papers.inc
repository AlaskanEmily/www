<h2>Papers and Presentations</h2>

The Mercury team have written quite a few papers about the Mercury
programming language, its implementation techniques, design, theoretical
basis and other topics. In addition, we have written several papers
on <a href = "papers.html#related">related</a> topics.
Almost all are available here as postscript
files, compressed using gzip.
<p>
Below the papers, the notes from a number of <a
href="papers.html#presentations">presentations</a> given on
Mercury, at a variety of levels, are also available.

<h2>Papers on Mercury</h2>

<ul>

<li>
<strong>
Towards parallel Mercury
</strong>
<br>
Thomas Conway.
<br>
<em>
Ph.D. thesis,
</em>
July 2002,
Department of Computer Science and Software Engineering,
The University of Melbourne,
<a href = "papers/conway-thesis.ps.gz">
Available here (562K).
</a>
<p>
This thesis presents the foundations for extending the implementation
of the declarative logic programming language Mercury
to support the parallel execution of programs.
<p>
The new material in this thesis is in three parts.
The first part
presents an extension to the existing (sequential) execution model for Mercury
that allows programs to be executed in parallel.
Programmers can exploit this extension simply
by replacing some sequential conjunction operators
connecting independent goals with a new parallel conjunction operator.
Such changes do not change the declarative semantics of the program,
but can improve performance.
<p>
The second part of the new material presents a model
for explicit threading in Mercury,
which is useful when the programmer's goal is not efficiency
but the explicit representation of concurrent tasks
and control of their interactions.
We show how our extended execution model
supports the usual operations on threads.
We also present a new interpretation for Mercury's system for input and output
that provides an intuitive understanding of the interactions
between the I/O operations executed by the different threads of a program
or by different programs.
<p>
The final part of the new material presented in this thesis
presents a new technique for obtaining
a detailed and accurate picture of the performance of a program.
The basis of our technique is
associating a complete context with each measurement,
rather than approximating the context as conventional profilers do.
In order to make our new profiling system feasible
we have had to develop sophisticated techniques
for reducing the cost of recording complete contexts;
in order to make its output tractable,
we also had to develop techniques for dealing with
interactions between higher order constructs and recursion.
We have also developed a tool for helping programmers
(and eventually compilers) to digest the large volume of data
generated by our profiling technique.
<p>
All the ideas presented in this thesis have been implemented in
the Melbourne Mercury compiler.
<p>

<li>
<strong>
Expressive type systems for logic programming languages
</strong>
<br>
David Jeffery.
<br>
<em>
Ph.D. thesis,
</em>
February 2002,
Department of Computer Science and Software Engineering,
The University of Melbourne,
<a href = "papers/dgj-thesis-final.ps.gz">
Available here (370K).
</a>
<p>
The aim of this thesis is the design of a type system
for an industrial strength logic programming language.
The type system we describe has been implemented
for the Mercury programming language, in the Melbourne Mercury compiler.
<p>
We begin by presenting a simple higher order extension
of the Mycroft-O'Keefe type system.
We then use this type system as a basis for two significant extensions.
<p>
The first extension is the adoption of a type class system similar to that
found in some modern functional languages
in the context of higher order logic programming.
We give a set of typing rules which
both provide a formal definition of type correctness
and define the source-to-source transformation we have used
to implement type classes.
This transformation is simple and effective,
and can be easily shown to preserve Mercury's
mode, determinism and uniqueness correctness properties.
<p>
The second extension is to allow existentially quantified type variables
in the types of function symbols and of predicates.
This represents the most significant contribution of this thesis.
We then formally define the type system that results from the combination
of both type classes and existential quantification of type variables.
The two type system extensions are quite orthogonal.
As a result, the definition of type correctness in the combined system
is a fairly simple combination of the definitions for the individual systems.
However, the mechanisms contributed by the two systems combine synergistically;
the resulting type system is extremely expressive.
<p>
We then show how the type system we have designed allows the programmer
to take advantage of many object oriented design techniques.
We give an in depth analysis of object oriented design
and isolate the mechanisms which are likely to result
in reusable and maintainable software systems.
We show that our type system allows the programmer
to directly express these kinds of designs
and discourages the use of the kinds of object oriented designs
which reduce maintainability
by introducing unnecessary implementation dependencies.
<p>
We show that these principles apply in a direct and simple manner
to the modelling of component interfaces
as supported by modern component frameworks such as CORBA.
We present MCORBA, an implementation of a CORBA binding for Mercury.
This interface is bi-directional,
allowing the programmer to write CORBA components in Mercury
and to use existing CORBA components from within Mercury programs.
<p>

<li>
<strong>
Constraint-based mode analysis of Mercury
</strong>
<br>
David Overton, Zoltan Somogyi and Peter Stuckey
<br>
<em>
to appear in the Proceedings of the Fourth International Conference on
Principles and Practice of Declarative Programming,
</em>
Pittsburgh, Pennsylvania, October 2002.
<a href = "papers/p33-overton.ps.gz">
Available here (188K).
</a>
<p>
Recent logic programming languages, such as Mercury and HAL,
require type, mode and determinism
declarations for predicates. This information allows the generation of
efficient target code and the detection of many errors at compile-time.
Unfortunately, mode checking in such languages is difficult. One of the main
reasons is that, for each predicate mode declaration,
the compiler is required to decide
which parts of the procedure bind which variables,
and how conjuncts in the predicate definition should be re-ordered
to enforce this behaviour.
Current mode checking systems limit the possible modes that may be used
because they do not keep track of aliasing information,
and have only a limited ability to infer modes,
since inference does not perform reordering.
In this paper we develop a mode inference system for Mercury
based on mapping each predicate to a system of Boolean constraints
that describe where its variables can be produced.
This allows us handle programs that are not supported by the existing system.
<p>

<li>
<strong>
Using the heap to eliminate stack accesses
</strong>
<br>
Zoltan Somogyi and Peter Stuckey
<br>
<em>
to appear in the Proceedings of the Fourth International Conference on
Principles and Practice of Declarative Programming,
</em>
Pittsburgh, Pennsylvania, October 2002.
<a href = "papers/p81-somogyi.ps.gz">
Available here (190K).
</a>
<p>
The value of a variable is often given by a field of a heap cell,
and frequently the program will pick up the values of several variables
from different fields of the same heap cell.
By keeping some of these variables out of the stack frame,
and accessing them in their original locations on the heap instead,
we can reduce the number of loads from and stores to the stack
at the cost of introducing a smaller number of loads from the heap.
We present an algorithm that finds the optimal set of variables
to access via a heap cell instead of a stack slot,
and transforms the code of the program accordingly.
We have implemented this optimization in the Mercury compiler,
and our measurements show that it can reduce program runtimes by up to 12%
while at the same time reducing program size.
The optimization is straightforward to apply to Mercury
and to other languages with immutable data structures;
its adaptation to languages with destructive assignment
would require the compiler to perform mutability analysis.
<p>

<li>
<strong>
Accurate garbage collection in an uncooperative environment
</strong>
<br>
Fergus Henderson
<br>
<em>
Proceedings of the 2002 International Symposium on Memory Management
</em>
Berlin, Germany, June 2002, pages 150-156.
<a href = "papers/high_level_gc.ps.gz">
Available here (83K).
</a>
<p>
Previous attempts at garbage collection in uncooperative environments
have generally used conservative or mostly-conservative approaches.
We describe a technique for doing fully type-accurate
garbage collection in an uncooperative environment,
using a ``shadow stack'' to link structs of pointer-containing variables,
together with the data or code needed to trace them.
We have implemented this in the Mercury compiler, which generates C code,
and present preliminary performance data on the overheads of this technique.
We also show how this technique can be extended to handle multithreaded
applications.
<p>

<li>
<strong>
Compiling Mercury to the .NET Common Language Runtime
</strong>
<br>
Tyson Dowd, Fergus Henderson, and Peter Ross
<br>
<em>
BABEL'01 First International Workshop on
Multi-Language Infrastructure and Interoperability,
</em>
Firenze, Italy, September 2001.  Preliminary Proceedings pages 70-85.
To appear in Electronic Notes in Theoretical Computer Science 59.1.
<a href = "papers/mercury_to_clr.ps.gz">
Available here (93K).
</a>
<p>
The .NET Common Language Runtime (CLR) offers a new opportunity to
experiment with multi-language interoperation, and provides a relatively
rare chance to explore deep interoperation of a wide range of
programming language paradigms.
This article describes how Mercury is compiled to the CLR.
We describe the problems we have
encountered with generating code for the CLR,
give some preliminary benchmark results,
and suggest some possible improvements to the CLR
regarding separate compilation, verifiability, tail calls, and efficiency.
<p>

<li>
<strong>
Compiling Mercury to high-level C code
</strong>
<br>
Fergus Henderson and Zoltan Somogyi
<br>
<em>
Proceedings of the 2002 International Conference on Compiler Construction
</em>
Grenoble, France, April 2002.
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href = "papers/hlc_cc.ps.gz">Available here (67K)</a>.
</a>
<p>
Many logic programming implementations compile to C,
but they compile to very low-level C, and thus discard many
of the advantages of compiling to a high-level language.
We describe an alternative approach to compiling logic
programs to C, based on continuation passing, that we have used
in a new back-end for the Mercury compiler.
The new approach compiles to much higher-level C code,
which means the compiler back-end and run-time system
can be considerably simpler.
<p>
We present a formal schema for the transformation,
and give benchmark results which show that this approach delivers
performance that is more than competitive
with the fastest previous implementation,
with greater simplicity and better portability and interoperability.
<p>
The approach we describe can also be used
for compiling to other target languages,
such as IL (the Microsoft .NET intermediate language).
<p>
The benchmark data on which the performance evaluation section of this paper
is based is
<a href = "papers/hlc_cc_perf.tar.gz">available here (9.7M)</a>.
<p>

<li>
<strong>
Deep profiling:
engineering a profiler for a declarative programming language
</strong>
<br>
Thomas C. Conway and Zoltan Somogyi
<br>
<em>
Technical Report 2001/24,
</em>
Department of Computer Science, University of Melbourne,
Melbourne, Australia, July 2001, 61 pages.
<a href = "papers/mu_01_24.ps.gz">
Available here (207K).
</a>
<p>
Declarative programs differ from imperative programs in several respects,
the main ones being their heavy use of recursion,
of various forms of polymorphism, and of higher order.
Existing profilers tend not to produce very useful information
in the presence of these constructs.
We present a new profiling technique we call \emph{deep profiling}
that yields detailed and useful information about programs
even in the presence of these constructs,
information that is significantly richer
than the output of other profilers.
<p>
The heart of deep profiling is a source-to-source transformation.
We have implemented this transformation and its associated infrastructure
in the compiler for Mercury, a purely declarative logic programming language.
While our measurements of this implementation
show that deep profiling has slightly greater overhead
than some other profiling techniques,
the wealth of information it provides
makes this extra overhead worthwhile.
The deep profiling algorithms themselves
are applicable to most other language styles,
including imperative, object-oriented, and functional languages.
<p>

<li>
<strong>
Practical aspects for a working compile time garbage collection system
for Mercury
</strong>
<br>
Nancy Mazur, Peter Ross, Gerda Janssens and Maurice Bruynooghe
<br>
<em>
Proceedings of ICLP 2001 - Seventeenth International Conference on 
Logic Programming
</em>,
Paphos, Cyprus, November 2001. Lecture Notes in Computer Science 2237, 
Springer Verlag, 
Pages 105-119
&copy;
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href = "papers/iclp2001_ctgc.ps.gz">
Available here (84K).
</a>
<p>
Compile-time garbage collection (CTGC) 
is still a very uncommon feature within
compilers. 
In previous work we have developed a compile-time structure
reuse system for Mercury, a logic programming language. 
This system 
indicates which datastructures can safely be reused at run-time. 
As preliminary experiments were promising, we 
have continued this work and have now a 
working and well performing near-to-ship
CTGC-system built into the Melbourne Mercury
Compiler (MMC). 
<br>
In this paper we present the multiple design decisions leading to this
system, we report the results of using CTGC 
for a set of benchmarks, including a
real-world program, and finally we discuss further
possible improvements. 
Benchmarks show substantial memory savings and a noticeable reduction
in execution time. 
<p>

<li>
<strong>
Binding-time analysis by constraint solving: a modular and
higher-order approach for Mercury
</strong>
<br>
Wim Vanhoof
<br>
<em>
Proceedings of the Seventh International Conference on Logic for
Programming and Automated Reasoning
</em>,
Reunion Island, France, November 2000.
Lecture Notes in Computer Science 1955,
Springer Verlag, 
Pages 399-416
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/bta_higher_order.ps.gz">Available here (106K)</a>.
<p>
In this paper we present a binding-time analysis for the logic
programming language Mercury. Binding-time analysis is a key analysis
needed to perform off-line program specialisation.  Our analysis deals
with the higher-order aspects of Mercury, and is formulated by means of
constraint normalisation. This allows (at least part of) the analysis to
be performed on a modular basis.
<p>

<li>
<strong>
A module based analysis for memory reuse in Mercury
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe
<br>
<em>
Proceedings of the First International Conference on Computational Logic 
</em>,
London, United Kingdom, July 2000.
Lecture Notes in Artificial Intelligence,
Springer Verlag, 
Pages 1255-1269
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/memory_reuse_analysis.ps.gz">Available here (93K)</a>.
<p>
In previous work Bruynooghe, Janssens and K&aring;gedal developed a
live-structure analysis for Mercury which detects memory cells available
for reuse.  Seperate compilation of modules is an essential ingredient
of a language such as Mercury which supports programming in the large.
Hence, to be practical, a live-structure analysis also has to be module
based.  This paper develops a modular live-structure analysis and
extends it with a modular reuse analysis.  It also describes preliminary
results obtained with a first prototype of the module based analysis.
<p>

<li>
<strong>
Making Mercury programs tail recursive
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi
<br>
<em>
Proceedings of the Ninth International Workshop on Logic-based Program
Synthesis and Transformation</em>,
Venice, Italy, September 1999.
To appear in Lecture Notes in Computer Science,
Springer Verlag, 
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/tail_lopstr_lncs.ps.gz">Available here (84K)</a>.
<p>
We present two optimizations for making Mercury programs tail recursive.
Both operate by taking computations that occur after a recursive call
and moving them before the recursive call, modifying them as necessary.
The first optimization moves calls to associative predicates;
it is a pure source to source transformation.
The second optimization moves construction unifications;
it required extensions to the mode system (to record aliases)
and to the parameter passing convention
(to allow arguments to be returned in memory).
The two optimizations are designed to work together,
and can make a large class of programs tail recursive.
<p>
The raw data on which the evaluation is based
is available as a <a href = "papers/tail_data.tar.gz">5 Kb tar file</a>.
<p>

<li>
<strong>
State update transformation
</strong>
<br>
Peter Ross and Zoltan Somogyi
<br>
<em>
</em>
<a href="papers/update.ps.gz">Available here (57K)</a>.
<p>
Recursive predicates frequently generate some state
which is updated after the recursive call.
We present a source to source transformation
which can move the state update before the recursive call,
thus helping to make the predicate tail recursive,
and report on its implementation in the Mercury compiler.
<p>

<li>
<strong>
Using impurity to create declarative interfaces in Mercury
</strong>
<br>
Tyson Dowd, Peter Schachte, Fergus Henderson and Zoltan Somogyi
<br>
<em>
</em>
<a href="papers/purity.ps.gz">Available here (52K)</a>.
<p>
The logic/functional language Mercury
allows the programmer to annotate predicates and
functions to mark impure predicates, allowing
impure code to be safely integrated into a
declarative language.
<p>
By using purity declarations with the foreign language
interface, programmers can take advantage of many of the
features of a high level programming language while
writing imperative code to interface with existing
imperative libraries.
<p>
This paper outlines the purity system in Mercury and
how it affects operational semantics,
compares this purity system with other approaches to declaring
impurity in a pure language,
and gives an extended example of how impurity and foreign language
interfaces can work together to simplify the chore of writing
declarative interfaces to libraries.
<p>

<li>
<strong>
Towards memory reuse for Mercury
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe
<br>
<em>
Proceedings of the International Workshop on Implementation of
Declarative Languages
</em>,
Paris, France, October 1999
<a href="papers/liveness.ps.gz">Available here (61K)</a>.
<p>
While Mercury allows destructive input/unique output modes which direct
the compiler to reuse memory, use of these modes can be cumbersome for
the programmer.  In most situations, it would be nicer if the programmer
didn't have to worry about the details of memory management.

The paper briefly reports on some experiments with a prototype analyser
which aims at detecting memory available for reuse. The prototype is
based on the live-structure analysis developed by us for logic programs
extended with declarations.

Yet the major contribution of this paper consists of the development of
the principles of a module based analysis which are essential for the
analysis of large Mercury programs with code distributed over many
modules.
<p>

<li>
<strong>
Binding-time analysis for Mercury
</strong>
<br>
Wim Vanhoof and Maurice Bruynooghe
<br>
<em>
Proceedings of the Sixteenth International Conference on Logic Programming
</em>,
Las Cruces, New Mexico, November 1999, pages 500-514
<a href="papers/bta.ps.gz">Available here (76K)</a>.
<p>
In this paper, we describe a binding-time analysis (BTA) for a
statically typed and strongly moded pure logic programming language, in
casu Mercury.  Binding-time analysis is the key concept in achieving
off-line program specialisation: the analysis starts from a description
of the program's input available for specialisation, and propagates this
information throughout the program, deriving directives for when and how
to perform specialisation.  Exploiting the possibilities offered by
Mercury's strong type and mode system, we present a completely automatic
BTA dealing with partially static binding-times.
<p>

<li>
<strong>
The implementation technology of the Mercury debugger
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
<br>
<em>
Proceedings of the Tenth Workshop on Logic Programming Environments
</em>,
Las Cruces, New Mexico, November 1999, pages 35-49.
<a href="papers/debugger_wlpe99.ps.gz">Available here (66K)</a>.
<p>

Every programming language needs a debugger.
Mercury now has three debuggers:
a simple procedural debugger
similar to the tracing systems of Prolog implementations,
a prototype declarative debugger,
and a debugger based on the idea of automatic trace analysis.
In this paper, we present the shared infrastructure
that underlies the three debuggers,
and describe the implementation of the procedural debugger.
We give our reasons for each of our main design decisions,
and show how several of these decisions are rooted in our experience
with the debugging of large programs working with large data structures.
<p>

<li>
<strong>
Making Mercury programs tail recursive (extended abstract)
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi.
<br>
<em>
Pre-Proceedings of the Ninth International Workshop on Logic-based Program
Synthesis and Transformation
</em>,
Venice, Italy, September 1999, pages 107-118.
<a href="papers/tail_lopstr.ps.gz">Available here (62K)</a>.
<p>

This paper has been superceded by the LNCS version.
<p>

<li>
<strong>
Run time type information in Mercury
</strong>
<br>
Tyson Dowd, Zoltan Somogyi, Fergus Henderson, Thomas Conway and David Jeffery.
<br>
<em>
Proceedings of the International Conference
on the Principles and Practice of Declarative Programming
</em>,
Paris, France, September/October 1999,
Lecture Notes in Computer Science 1702, 
Springer Verlag, 
Pages 224-243,
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/rtti_ppdp.ps.gz">Available here (75K)</a>.
<p>

The logic/functional language Mercury
uses a strong, mostly static type system
based on polymorphic many-sorted logic.
For efficiency,
the Mercury compiler uses type specific representations of terms,
and implements polymorphic operations such as unifications
via generic code invoked with descriptions of the actual types of the operands.
These descriptions, which consist of automatically generated data and code,
are the main components of the Mercury runtime type information (RTTI) system.
We have used this system to implement several extensions of the Mercury system,
including an escape mechanism from static type checking,
generic input and output facilities, a debugger, and automatic memoization,
and we are in the process of using it
for an accurate, native garbage collector.
We give detailed information
on the implementation and uses of the Mercury RTTI system
as well as measurements of the space costs of the system.
<p>
The raw data on which the evaluation is based
is available as a <a href = "papers/rtti_data.tar.gz">70 Kb tar file</a>
<p>

<li>
<strong>
Optimization of Mercury programs
</strong>
<br>
Simon Taylor.
<br>
<em>
Honours report.
</em>
Department of Computer Science, University of Melbourne, November 1998.
<a href = "papers/stayl_hons.ps.gz">
Available here (120K).
</a>
<p>

This paper describes the implementation of several of the high-level
optimization passes of the Mercury compiler, including deforestation,
type specialization, constraint propagation and structure reuse.
<p>

<li>
<strong>
MCORBA: A CORBA Binding for Mercury
</strong>
<br>
David Jeffery, Tyson Dowd and Zoltan Somogyi.
<br>
In <em>
Proceedings of the First International Workshop
on Practical Aspects of Declarative Languages
</em>,
San Antonio, Texas,
January 1999, 
Lecture Notes in Computer Science 1551, 
Springer Verlag, 
Pages 211-227,
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/mcorba_padl99.ps.gz">Available here (65K)</a>.
<p>

MCORBA is a binding to the CORBA distributed object framework
for the purely declarative logic/functional language Mercury.
The binding preserves the referential transparency of the language,
and has several advantages
over similar bindings for other strongly typed declarative languages.
As far as we know, it is the first such binding to be bidirectional;
it allows a Mercury program both to operate upon CORBA components
and to provide services to other CORBA components.
Whereas the Haskell binding for COM
maps COM interfaces onto Haskell types,
MCORBA maps CORBA interfaces onto Mercury type classes.
Our approach simplifies the mapping,
makes the implementation of CORBA's interface inheritance straightforward,
and makes it trivial for programmers to provide
several different implementations of the same interface.
It uses existential types to model the operation
of asking CORBA for an object that satisfies a given interface
but whose representation is unknown.
<p>

<li>
<strong>
Type classes in Mercury
</strong>
<br>
David Jeffery, Fergus Henderson and Zoltan Somogyi.
<br>
<em>
Technical Report 98/13,
</em>
Department of Computer Science, University of Melbourne,
Melbourne, Australia, September 1998, 22 pages.
<a href = "papers/mu_98_13.ps.gz">
Available here (82K).
</a>
<p>

In this paper, we explain how we have extended Mercury's type system 
to include support for type classes.
We give a formal semantics for this extension to our type system,
adapting the typing rules used in functional languages
to the differing demands of logic programming languages.
We show that type classes integrate very nicely
with Mercury's mode, uniqueness and determinism systems,
and describe how our implementation works.
<p>

<li>
<strong>
Termination analysis for Mercury
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
<br>
<em>
Proceedings of the Fourth Static Analysis Symposium
</em>,
Paris, France, September 1997, pages 157-171.
<a href = "papers/sas97.ps.gz">available here (75K)</a>.
A longer version of the paper appeared as
Technical Report 97/9,
Department of Computer Science, University of Melbourne,
Melbourne, Australia, July 1997, 25 pages.
it is <a href = "papers/mu_97_09.ps.gz">available here (99K)</a>.
<p>

This paper presents the algorithms of the Mercury termination analyser,
discusses how real-world aspects of the language
such as modules, higher-order features, foreign language code,
and declarative input/output can be handled,
and evaluates the performance of the analyser
both on a set of standard test programs and on the Mercury compiler itself.
<p>
The raw data on which the evaluation is based is available
as a <a href = "papers/termination_data.tar.gz">5.2 Mb tar file</a>.
<p>

<li>
<strong>
Status of the Mercury system
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<br>
<em>
Proceedings of the JICSLP '96 Workshop on Parallelism and
Implementation Technology for (Constraint) Logic Programming Languages,
</em>
Bonn, Germany, September 1996, pages 207-218.
<a href = "papers/jicslpw.ps.gz">Available here (46K)</a>.
<p>

<li>
<strong>
The execution algorithm of Mercury:
an efficient purely declarative logic programming language
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Journal of Logic Programming,
</em>
volume 29, number 1-3, October-December 1996, pages 17-64.
<a href = "papers/jlp.ps.gz">Available here (138K)</a>.
<br>
Elsevier owns the copyright of this paper;
it is made available here by their permission.
<p>

This paper contains a brief overview of the Mercury language, and a
reasonably detailed overview of the implementation technology used in
the Mercury compiler.  It describes the abstract machine that the
compiler generates code for.  (Our other papers listed below go
into more detail on exactly how the code is generated, and on how
the abstract machine instructions are implemented as C or GNU C code.)
<p>
The raw data on which the evaluation is based
is available on our <a href = "./benchmarks.html">benchmarking page</a>.
<p>

<li>
<strong>
Determinism analysis in the Mercury compiler
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<br>
<em>
Proceedings of the Australian Computer Science Conference,
</em>
Melbourne, Australia, January 1996, pages 337-346.
<a href = "papers/acsc96.ps.gz">Available here (78K)</a>.
A longer version of the paper is
<a href = "papers/detism.ps.gz">available here (76K)</a>.
<p>

This paper discusses Mercury's determinism system in detail, including
the algorithms for switch detection, deep indexing, determinism
inference, and determinism checking.
<p>

<li>
<strong>
Code generation for Mercury
</strong>
<br>
Thomas Conway, Fergus Henderson, and Zoltan Somogyi.
<br>
<em>
Proceedings of the 1995 International Symposium on Logic Programming,
</em>
Portland, Oregon, December 1995, pages 242-256.
<a href = "papers/code_gen_mit.ps.gz">Available here (68K)</a>.
<p>

This paper describes the structure of the Mercury compiler,
its calling conventions,
and the algorithms it uses in generating code.
These algorithms include lazy code generation
and a novel way of handling nested disjunctions.
<p>

<li>
<strong>
Compiling logic programs to C
using GNU C as a portable assembler
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<br>
<em>
Proceedings of the ILPS '95 Postconference Workshop on
Sequential Implementation Technologies for Logic Programming Languages.
</em>
Portland, Oregon, December 1995.
<a href = "papers/mercury_to_c.ps.gz">Available here (65K)</a>.
<p>

This paper discusses the merits of using C, and in particular GNU C,
as an intermediate target language for the compilation of logic programs,
and describes the approach we have taken in the implementation of Mercury.
<p>

<li>
<strong>
Mercury: an efficient purely declarative logic programming language
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Proceedings of the Australian Computer Science Conference,
</em>
Glenelg, Australia, February 1995, pages 499-512.
<a href = "papers/acsc95.ps.gz">Available here (85K)</a>.
<p>

An overview paper.
<p>

<li>
<strong>
The implementation of Mercury:
an efficient purely declarative logic programming language
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Proceedings of the ILPS '94 Postconference Workshop on
Implementation Techniques for Logic Programming Languages,
</em>
Syracuse, New York, November 1994.
<a href = "papers/ilps94w.ps.gz">Available here (96K)</a>.
<p>

The first paper on Mercury. It is superseded by the paper
in the Journal of Logic Programming.
<p>

<li>
<strong>
Code generation for Mercury
</strong>
<br>
Thomas Conway.
<br>
<em>
Honours report.
</em>
Department of Computer Science, University of Melbourne, November 1994.
<a href = "papers/conway_hons.ps.gz">Available here (188K)</a>.
<p>

This is the first paper on the code generator.
Warning: several aspects of the code generator have changed
since this paper was written.
Some of these are documented in the version in the ILPS 95 proceedings.

</ul>

<hr>

<h2><a name="related">Related Papers</a></h2>

This paper gives an introduction to automatic termination analysis.
It surveys termination analysis of logic programs and provides an
overview of the important concepts involved in automatic termination
analysis.  
<p>

<ul>
<li>
<strong>
Termination analysis for logic programs
</strong>
<br>
Chris Speirs.
<br>
<em>
Technical Report 97/23,
</em>
Department of Computer Science, University of Melbourne, October 1997.
<a href = "papers/mu_97_23.ps.gz">
Available here (67K).
</a>
 
</ul>

<p>
This paper outlines the features that we believe to be important
in a modern logic programming language:
<p>

<ul>
<li>
<strong>
Logic programming for the real world
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway and Richard O'Keefe.
<br>
<em>
Proceedings of the ILPS '95 Postconference Workshop on
Visions for the Future of Logic Programming,
</em>
Portland, Oregon, December 1995.
<a href = "papers/vision.ps.gz">
Available here (59K).
</a>
<p>

</ul>

The mode system and the uniqueness system of Mercury
are based on the following papers:
<p>

<ul>

<li>
<strong>
A system of precise modes for logic programs
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
Proceedings of the Fourth International Conference on Logic Programming,
</em>
Melbourne, Australia, May 1987, pages 769-787.
<a href = "http://www.cs.mu.oz.au/~zs/papers/iclp87.ps.gz">
Available here (40K).
</a>
<p>

<li>
<strong>
Strong modes can change the world!
</strong>
<br>
Fergus Henderson.
<br>
<em>
Honours Report.
</em>
Department of Computer Science, University of Melbourne, November 1992.
<a href = "http://www.cs.mu.oz.au/~fjh/papers/hons_thesis.ps.gz">
Available here (114K).
</a>
<p>

</ul>

The following paper describes the method used to express database 
transactions and updates that is used in the Mercury ODBC database
interface.
<!---------- The Aditi interface is not useful yet
--------------------------------------------------
The same kind of approach is also used in
the Mercury interface to the Aditi deductive
database system (see the "Aditi deductive database interface"
section in Mercury Language Reference Manual listed under 
"Implementation dependent pragmas" in the "Pragmas" chapter).
--------------------------------------------------
-------------------------------------------------->

<p>
<ul>

<li>
<strong>
Database transactions in a purely declarative logic programming language
</strong>
<br>
David B. Kemp, Thomas Conway, Evan Harris, Fergus Henderson,
Kotagiri Ramamohanarao and Zoltan Somogyi.
<br>
<em>
Technical Report 96/45
</em>
Department of Computer Science, University of Melbourne, December 1996.
<a href = "http://www.cs.mu.OZ.AU/publications/tr_db/mu_96_45.ps.gz">
Available here (58K)
</a>
<a href = "http://www.cs.mu.OZ.AU/publications/tr_db/mu_96_45_cover.ps.gz">
with cover page.
</a>

</ul>

<!---------- The Aditi interface is not useful yet
--------------------------------------------------

The following paper is also relevant to the Aditi interface mentioned above.
It describes a source-to-source transformation implemented in the
Mercury compiler.

<li>
<strong>
Right-, left-, and multi-linear rule transformations that maintain
context information
</strong>
<br>
David B. Kemp and Kotagiri Ramamohanarao and Zoltan Somogyi. 
<br>
<em>
Technical Report 90/2
</em>
Department of Computer Science, University of Melbourne, October 1997.
<a href = "papers/tr90-2.ps.gz">
Available here (48K).
</a>
Note that this paper incorrectly claims that
the context transformation can be applied to
mixed-linear predicates containing pseudo-left-linear rules
as well as other linear rules.  
It is corrected in David Kemp's thesis,
<a href = "http://www.cs.mu.oz.au/~kemp/papers/thesis.ps.gz">
available here (560K).
</a>

</ul>

--------------------------------------------------
-------------------------------------------------->
 
<hr>

<h2><a name="presentations">Presentations on Mercury<a></h2>

<ul>

<li>
<strong>
Termination analysis for Mercury
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
<br>
<em>
Talk presented at the Fourth Static Analysis Symposium.
</em>
Paris, France, September 1997.
<a href = "papers/sas_talk.ps.gz">
Available here (6K).
</a>
<p>

<li>
<strong>
Unification in Mercury
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
Invited talk presented at the Eighth Benelux Workshop on Logic Programming.
</em>
Louvain-la-Neuve, Belgium, September 1996.
<a href = "papers/unif.ps.gz">
Available here (12K).
</a>
<p>

<li>
<strong>
The design and implementation of Mercury
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
<br>
<em>
Tutorial presented at the Joint International
Conference and Symposium on Logic Programming.
</em>
Bonn, Germany, September 1996.
<a href = "papers/jicslp_talk.ps.gz">
Available here (18K).
</a>
<p>

<li>
<strong>
Status of the Mercury system
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<br>
<em>
Presented at the JICSLP '96 Workshop on Parallelism and
Implementation Technology for (Constraint) Logic Programming Languages,
</em>
Bonn, Germany, September 1996.
<a href = "papers/jicslpw_talk.ps.gz">
Available here (5K).
</a>
<p>

<li>
<strong>
Mercury:
an efficient purely declarative logic programming language
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Presented at the Eighteenth Australasian Computer Science Conference,
</em>
Adelaide, South Australia, February 1995.
<a href = "papers/acsc95_slides.ps.gz">
Available here (33K).
</a>
<p>

<li>
<strong>
Lecture notes for the expanded Mercury segment of the subject
433-257 Frontiers of Computer Science, given in 1999
(whereas the segment in 1997 had four lectures, in 1999 it had six)
</strong>
<br>
Zoltan Somogyi.
<br>
<a href = "papers/257_1999.ps.gz">
Available here (40K).
</a>
<p>

<li>
<strong>
Lecture notes for the Mercury segment of the subject
433-257 Frontiers of Computer Science, given in 1997
</strong>
<br>
Zoltan Somogyi.
<br>
<a href = "papers/257.ps.gz">
Available here (21K).
</a>
<p>

<li>
<strong>
Lecture notes for the Mercury segment of the subject
433-247 Frontiers of Computer Science, given in 1995
</strong>
<br>
Zoltan Somogyi.
<br>
<a href = "papers/247.ps.gz">
Available here (21K).
</a>
<p>

<li>
<strong>
Type classes for logic programming languages, given in March 1998
</strong>
<br>
David Jeffery.
<br>
<a href = "papers/dgj-talk.ps.gz">
Available here (30K).
</a>
<p>

<li>
<strong>
Runtime type information in Mercury, given in March 1998
</strong>
<br>
Tyson Dowd.
<br>
<a href = "papers/rtti_talk_98.ps.gz">
Available here (48K).
</a>
<p>

</ul>

<p>
<hr>
<p>

All these papers and presentations are for A4 paper.
Unfortunately, we cannot generate US paper size versions.

<p>
