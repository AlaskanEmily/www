<!--
WHEN UPDATING THIS FILE, REMEMBER TO UPDATE THE TABLE OF CONTENTS!
-->

<h2>Papers and Presentations</h2>

The Mercury team have written quite a few papers about the Mercury
programming language, its implementation techniques, design, theoretical
basis and other topics. In addition, we have written several papers
on <a href = "papers.html#related">related</a> topics.
Almost all are available here as postscript
files, compressed using gzip.
<p>
Below the papers, the notes from a number of <a
href="papers.html#presentations">presentations</a> given on
Mercury, at a variety of levels, are also available.

<h2>Contents</h2>
<h3><a href = "papers.html#mercury">Papers on Mercury</a></h3>

<ul>

<li>
<strong>
<a href = "papers.html#dd3">
Divide-and-query and subterm dependency tracking in the Mercury declarative
debugger
</a>
</strong>
<br>
Ian MacLarty, Zoltan Somogyi and Mark Brown.
<em>
Sixth International Symposium on
Automated and Analysis-driven Debugging,
</em>
Monterey, California, September 2005.
<p>

<li>
<strong>
<a href = "papers.html#decl_debug">
Annotated event traces for declarative debugging
</a>
</strong>
<br>
Mark Brown and Zoltan Somogyi
<em>
Unpublished,
</em>
Melbourne, 2005.
<p>

<li>
<strong>
<a href = "papers.html#mazur-thesis">
Compile-time garbage collection for the declarative language Mercury
</a>
</strong>
<br>
Nancy Mazur.
<em>
Ph.D. thesis,
</em>
Catholic University of Leuven, Belgium, May 2004.
<p>

<li>
<strong>
<a href = "papers.html#dmo-thesis">
Precise and expressive mode systems for typed logic programming languages
</a>
</strong>
<br>
David Overton.
<em>
Ph.D. thesis,
</em>
Melbourne, 2003.
<p>

<li>
<strong>
<a href = "papers.html#aadebug03-paper">
Idempotent I/O for safe time travel
</a>
</strong>
<br>
Zoltan Somogyi.
<em>
Proceedings of the Fifth International Workshop on Automated Debugging,
</em>
Ghent, Belgium, September 2003.
<p>

<li>
<strong>
<a href = "papers.html#juliensf-hons">
Termination analysis for Mercury using convex constraints
</a>
</strong>
<br>
Julien Fischer.
<em>
Honours report,
</em>
Melbourne, 2002.
<p>

<li>
<strong>
<a href = "papers.html#conway-thesis">
Towards parallel Mercury
</a>
</strong>
<br>
Thomas Conway.
<em>
Ph.D. thesis,
</em>
Melbourne, 2002.
<p>

<li>
<strong>
<a href = "#dgj-thesis-final">
Expressive type systems for logic programming languages
</a>
</strong>
<br>
David Jeffery.
<em>
Ph.D. thesis,
</em>
Melbourne,
2002.
<p>

<li>
<strong>
<a href = "#p33-overton">
Constraint-based mode analysis of Mercury
</a>
</strong>
<br>
David Overton, Zoltan Somogyi and Peter Stuckey.
<em>PPDP'02</em>, Pittsburgh.
<p>

<li>
<strong>
<a href = "papers.html#p81-somogyi">
Using the heap to eliminate stack accesses
</a>
</strong>
<br>
Zoltan Somogyi and Peter Stuckey.
<em>PPDP'02</em>, Pittsburgh.
<p>

<li>
<strong>
<a href = "papers.html#high_level_gc">
Accurate garbage collection in an uncooperative environment
</a>
</strong>
<br>
Fergus Henderson.
<em>ISMM'02</em>, Berlin.
<p>

<li>
<strong>
<a href = "papers.html#mercury_to_clr">
Compiling Mercury to the .NET Common Language Runtime
</a>
</strong>
<br>
Tyson Dowd, Fergus Henderson, and Peter Ross.
<em>BABEL'01</em>, Firenze, Italy.  To appear in <em>ENTCS 59.1</em>.
<p>

<li>
<strong>
<a href = "papers.html#hlc_cc">
Compiling Mercury to high-level C code
</a>
</strong>
<br>
Fergus Henderson and Zoltan Somogyi.
<em>CC'02</em>, Grenoble, France.
<p>

<li>
<strong>
<a href = "papers.html#mu_01_24">
Deep profiling:
engineering a profiler for a declarative programming language
</a>
</strong>
<br>
Thomas C. Conway and Zoltan Somogyi.
<em>Tech Report 2001/24</em>, Melbourne.
<p>

<li>
<strong>
<a href = "papers.html#iclp2001_ctgc">
Practical aspects for a working compile time garbage collection system
for Mercury
</a>
</strong>
<br>
Nancy Mazur, Peter Ross, Gerda Janssens and Maurice Bruynooghe.
<em>ICLP'01</em>, Paphos, Cyprus. <em>LNCS 2237</em>.
<p>

<li>
<strong>
<a href="papers.html#bta_higher_order">
Binding-time analysis by constraint solving: a modular and
higher-order approach for Mercury
</a>
</strong>
<br>
Wim Vanhoof.
<em>LPAR'00</em>, Reunion Island, France. <em>LNCS 1955</em>.
<p>

<li>
<strong>
<a href="papers.html#memory_reuse_analysis">
A module based analysis for memory reuse in Mercury
</a>
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe.
<em>ICCL'00</em>, London.  <em>LNAI</em>.
<p>

<li>
<strong>
<a href="papers.html#tail_lopstr_lncs">
Making Mercury programs tail recursive
</a>
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi.
<em>LOPSTR'99</em>, Venice, Italy.  <em>LNCS</em>.
<p>

<li>
<strong>
<a href="papers.html#update">
State update transformation
</a>
</strong>
<br>
Peter Ross and Zoltan Somogyi.
<p>

<li>
<strong>
<a href="papers.html#purity">
Using impurity to create declarative interfaces in Mercury
</a>
</strong>
<br>
Tyson Dowd, Peter Schachte, Fergus Henderson and Zoltan Somogyi.
<em>Tech Report 2000/17</em>, Melbourne, 2000.
<p>

<li>
<strong>
<a href="papers.html#liveness">
Towards memory reuse for Mercury
</a>
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe.
<em>IDL'99</em>, Paris.
<p>

<li>
<strong>
<a href="papers/bta_higher_order.ps.gz">
Binding-time analysis for Mercury
</a>
</strong>
<br>
Wim Vanhoof and Maurice Bruynooghe.
<em>ICLP'99</em>, Las Cruces, New Mexico
<p>

<li>
<strong>
<a href="papers.html#debugger_wlpe99">
The implementation technology of the Mercury debugger
</a>
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
<em>WLPE'99</em>, Las Cruces, New Mexico.
<p>

<li>
<strong>
<a href="papers.html#tail_lopstr">
Making Mercury programs tail recursive (extended abstract)
</a>
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi.
<em>LOPSTR'99</em>, Venice, Italy.
<p>

<li>
<strong>
<a href="papers.html#rtti_ppdp">
Run time type information in Mercury
</a>
</strong>
<br>
Tyson Dowd, Zoltan Somogyi, Fergus Henderson, Thomas Conway and David Jeffery.
<br>
<em>PPDP'99</em>, Paris. <em>LNCS 1702</em>.
<p>

<li>
<strong>
<a href = "papers.html#stayl_hons">
Optimization of Mercury programs
</a>
</strong>
<br>
Simon Taylor.
<em>Honours report</em>, Melbourne, 1998.
<p>

<li>
<strong>
<a href="papers.html#mcorba_padl99">
MCORBA: A CORBA Binding for Mercury
</a>
</strong>
<br>
David Jeffery, Tyson Dowd and Zoltan Somogyi.
<em>PADL'99</em>, San Antonio, Texas.  <em>LNCS 1551</em>.
<p>

<li>
<strong>
<a href = "papers.html#mu_98_13">
Type classes in Mercury
</a>
</strong>
<br>
David Jeffery, Fergus Henderson and Zoltan Somogyi.
<em>Tech Report 98/13</em>, Melbourne, 1998.
<p>

<li>
<strong>
<a href = "papers.html#sas97">
Termination analysis for Mercury
</a>
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
<em>SAS'97</em>, Paris.
<p>

<li>
<strong>
<a href = "papers.html#jicslpw">
Status of the Mercury system
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<em>JICSLP'96 implementation workshop</em>, Bonn, Germany.
<p>

<li>
<strong>
<a href = "papers.html#jlp">
The execution algorithm of Mercury:
an efficient purely declarative logic programming language
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<em>JLP</em>, 1996.
<p>

<li>
<strong>
<a href = "papers.html#acsc96">
Determinism analysis in the Mercury compiler
</a>
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<br>
<em>ACSC'96</em>, Melbourne.
<p>

<li>
<strong>
<a href = "papers.html#code_gen_mit">
Code generation for Mercury
</a>
</strong>
<br>
Thomas Conway, Fergus Henderson, and Zoltan Somogyi.
<br>
<em>ILPS'95</em>, Portland, Oregon.
<p>

<li>
<strong>
<a href = "papers.html#mercury_to_c">
Compiling logic programs to C
using GNU C as a portable assembler
</a>
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<em>ILPS'95 implementation workshop</em>,
Portland, Oregon.
<p>

<li>
<strong>
<a href = "papers.html#acsc95">
Mercury: an efficient purely declarative logic programming language
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<em>ASCS'95</em>, Glenelg, Australia.
<p>

<li>
<strong>
<a href = "papers.html#ilps94w">
The implementation of Mercury:
an efficient purely declarative logic programming language
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<em>
ILPS'94 Postconference Workshop on
Implementation Techniques for Logic Programming Languages,
</em>
Syracuse, New York.
<p>

<li>
<strong>
<a href = "papers.html#conway_hons">
Code generation for Mercury
</a>
</strong>
<br>
Thomas Conway.
<em>Honours report</em>, Melbourne, 1994.
<p>

</ul>

<h3><a href = "papers.html#related">Related papers</a></h3>

<ul>
<li>
<strong>
<a href = "papers.html#mu_97_23">
Termination analysis for logic programs
</a>
</strong>
<br>
Chris Speirs.
<em>Tech Report 97/23</em>, Melbourne, 1997.
<p>

<li>
<strong>
<a href = "papers.html#vision">
Logic programming for the real world
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway and Richard O'Keefe.
<em>ILPS'95 ``visions'' workshop</em>, Portland, Oregon.
<p>

<li>
<strong>
<a href = "papers.html#iclp87">
A system of precise modes for logic programs
</a>
</strong>
<br>
Zoltan Somogyi.
<em>ICLP'87</em>, Melbourne.
<p>

<li>
<strong>
<a href = "papers.html#fjh_hons_thesis">
Strong modes can change the world!
</a>
</strong>
Fergus Henderson.
<br>
<em>Honours Report</em>, Melbourne, 1992.
<p>

<li>
<strong>
<a href = "papers.html#mu_96_45">
Database transactions in a purely declarative logic programming language
</a>
</strong>
<br>
David B. Kemp, Thomas Conway, Evan Harris, Fergus Henderson,
Kotagiri Ramamohanarao and Zoltan Somogyi.
<em>Tech Report 96/45</em>, Melbourne, 1996.

<li>
<strong>
<a href = "papers.html#tr90-2">
Right-, left-, and multi-linear rule transformations that maintain
context information
</a>
</strong>
<br>
David B. Kemp and Kotagiri Ramamohanarao and Zoltan Somogyi. 
<br>
<em>Tech Report 90/2</em>, Melbourne, 1997.
 
</ul>

<h3><a href = "papers.html#presentations">Presentations</a></h3>

<ul>

<li>
<strong>
<a href = "papers.html#aadebug03-talk">
Idempotent I/O for safe time travel
</a>
</strong>
<br>
Zoltan Somogyi.
Invited talk presented at
the Fifth International Workshop on Automated Debugging,
Ghent, Belgium, September 2003.
<p>

<li>
<strong>
<a href="papers.html#sas_talk">
Termination analysis for Mercury
</a>
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
Talk presented at <em>SAS'97</em>, Paris.
<p>

<li>
<strong>
<a href = "papers.html#unif">
Unification in Mercury
</a>
</strong>
<br>
Zoltan Somogyi.
<em>
Invited talk presented at the Eighth Benelux Workshop on Logic Programming,
</em>
Louvain-la-Neuve, Belgium, 1996.
<p>

<li>
<strong>
<a href="papers.html#jicslp_talk">
The design and implementation of Mercury
</a>
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
Tutorial presented at <em>JICSLP'96</em>, Bonn, Germany.
<p>

<li>
<strong>
<a href = "papers.html#jicslpw_talk">
Status of the Mercury system
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<br>
Presented at <em>the JICSLP '96 Workshop on Parallelism and
Implementation Technology for (Constraint) Logic Programming Languages,
</em>
Bonn, Germany.
<p>

<li>
<strong>
<a href = "papers.html#acsc95_slides">
Mercury:
an efficient purely declarative logic programming language
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
Presented at <em>ACSC'95</em>, Adelaide, South Australia.
<p>

<li>
<strong>
<a href = "papers.html#257_1999">
Mercury lecture notes for 433-257 (expanded)
</a>
</strong>
<br>
Zoltan Somogyi, 1999.
<p>

<li>
<strong>
<a href = "papers.html#257">
Mercury lecture notes for 433-257
</a>
</strong>
<br>
Zoltan Somogyi, 1997.
<p>

<li>
<strong>
<a href = "papers.html#247">
Mercury lecture notes for 433-247
</a>
</strong>
<br>
Zoltan Somogyi, 1995.
<p>

<li>
<strong>
<a href = "papers.html#dgj-talk">
Type classes for logic programming languages
</a>
</strong>
<br>
David Jeffery, 1998.
<p>

<li>
<strong>
<a href = "papers.html#rtti_talk_98">
Runtime type information in Mercury
</a>
</strong>
<br>
Tyson Dowd, 1998.
<p>

</ul>

<hr>

<h2><a name="mercury">Papers on Mercury</a></h2>

<ul>

<li>
<strong>
<a name="dd3">
Divide-and-query and subterm dependency tracking in the Mercury declarative
debugger
</a>
</strong>
<br>
Ian MacLarty, Zoltan Somogyi and Mark Brown
<br>
<em>
Sixth International Symposium on
Automated and Analysis-driven Debugging.
</em>
Monterey, California, September 2005.
Available in
<a href = "papers/dd3.pdf">
pdf (204k)
</a>
or
<a href = "papers/dd3.ps.gz">
ps.gz (161k)
</a>
formats.  
<p>
We have implemented a declarative debugger for Mercury
that is capable of finding bugs in large, long-running programs.
This debugger implements several search strategies.
We discuss the implementation of two of these strategies
and the conditions under which each strategy is useful.
</p>
<p>
The divide and query strategy
tries to minimize the number of questions asked of the user.
While divide and query can reduce the number of questions
to roughly logarithmic in the size of the computation,
implementing it presents practical difficulties
for computations whose representations do not fit into memory.
We discuss how we get around this problem,
making divide and query practical.
</p>
<p>
Our declarative debugger allows users to specify
exactly which part of an atom is wrong.
The subterm dependency tracking strategy
exploits this extra information to jump directly
to the part of the program that computed the wrong subterm.
In many cases, only a few such jumps are required to arrive at the bug.
Subterm dependency tracking can converge on the bug
even more quickly than divide and query,
and it tends to yield question sequences that are easier for users to answer.
</p>
<p>
&copy; ACM, (2005). This is the author's version of the work. It is
posted here by permission of ACM for your personal use. Not for
redistribution. The definitive version was published in  
Proceedings of the Sixth International Symposium on
Automated and Analysis-driven Debugging.
</p>
<li>
<strong>
<a name="decl_debug">
Annotated event traces for declarative debugging
</a>
</strong>
<br>
Mark Brown and Zoltan Somogyi
<br>
<em>
Unpublished,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
2005.
Available in
<a href = "papers/decl_debug.pdf">
pdf (261k)
</a>
or
<a href = "papers/decl_debug.ps.gz">
ps.gz (94k)
</a>
formats.
<p>
Many programmers find debugging a frustrating and unproductive activity.
Declarative debugging 
promises to alleviate this problem by automating
some of the reasoning used in the debugging process.
We have implemented a declarative debugger for Mercury.
In the process, we found a problem not addressed
in the existing literature on declarative debuggers,
which considers programs to consist of clauses
(conjunctions of literals):
how to handle if-then-elses.
The problem is that the condition of an if-then-else
should be treated as a negated goal if and only if the condition fails.
Negated contexts may cause a declarative debugger
to switch from wrong answer analysis to missing answer analysis and vice versa.
Since missing answer analysis explores a search space
that is subtly different from the space explored for wrong answer analysis,
the two kinds of analysis need different kinds of trees
to represent the program execution.
For the conditions of if-then-elses,
the debugger does not know which kind of tree to build
until the condition has either succeeded or failed,
by which time it is too late.
To solve this problem,
we have designed a novel data structure, the annotated event trace,
which is flexible enough to support both wrong and missing answer analysis.
The advantages of this data structure are that it is quite compact,
requiring little more space than an ordinary stored event trace,
and that the algorithms to build this data structure
and to derive from it the information required for two kinds of diagnosis
are all simple as well as efficient.
</p>

<li>
<strong>
<a name="mazur-thesis">
Compile-time garbage collection for the declarative language Mercury
</a>
</strong>
<br>
Nancy Mazur
<br>
<em>
Ph.D. thesis,
</em>
Department of Computer Science,
Catholic University of Leuven,
Belgium,
May 2004.
<a href = "papers/CW2004_03_mazur.pdf">
Available here (1.7M).
</a>
<p>
One of the key advantages of modern programming languages
is that they free the programmer from the burden of explicit memory management.
Usualy, this means that memory management is delegated to the runtime system
by the use of a run-rime garbage collector (RTGC).
Basically, a RTGC is a dedicated process
that is run in parallel with the user program.
Whever the user program needs to store some data,
the RTGC provides the desired memory space.
At regular intervals, the RTGC reviews the uses of the allocated memory space,
and recovers those memory cells that have become garbage,
i.e. that cannot be accessed any more by the user program.
</p>
A complementary form of automatic memory management
is compile-time garbage collection (CGTC),
where the decisions form memory management
are taken at compile time instead of at run-time.
The compiler determines the lifetime of the variables
that are created during the execution of the program,
and thus also the memory that will be associated with these variables.
Whenever the compiler can guarantee that a variable,
or more precisely, parts of the memory resources
that this variable points to at run-time,
wil never ever be accessed beyond a certain program instruction,
then the compiler can add instructions to deallocate these resources
at that particular instruction
without compromising the correctness of the code.
If the program instruction is followed by a series of instructions
that require the allocation of new memory cells, then the compiler
can replace the sequence of deallocation and allocation instructions,
by instructions updating the garbage cells, thus reusing these cells.
<p>
We study the technique of compile-time garbage collection
in the context of Mercury, a pure declarative language.
A key element  of declarative languages is that
they disallow explicit memory updates
(which are common operations in most other programming paradigms)
but they rely instead on term construction and deconstruction
to manipulate the program data.
This places a high demand on the memory management
and makes declarative languages a primary target
for compile-time garbage collection.
Moreover, the clear mathematical foundations of Mercury,
being a pure declarative language,
makes the development of the program analyses
that are necessary for CTGC feasible.
</p>
In this thesis we define a number of semantics
for the logic programming language Mercury
and formally establish the equivalence between them;
we use these semantics to formalise the different program analysis steps
that are needed to implement a basic CTGC system for Mercury
and prove their safeness.
We extend this basic CGTC system such that it is able to correctly deal
with programs organised into modules and we implement a complete CTGC system
within the Melbourne Mercury Compiler.
To the best of our knowledge,
this is the first and only complete CTGC system
that has ever been built for a programming language.
</p>

<li>
<strong>
<a name="dmo-thesis">
Precise and expressive mode systems for typed logic programming languages
</a>
</strong>
<br>
David Overton.
<br>
<em>
Ph.D. thesis,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
December 2003.
<a href = "papers/dmo-thesis.ps.gz">
Available here (602K).
</a>
<p>
In this thesis we look at mode analysis of logic programs.
Being based on the mathematical formalism of predicate logic,
logic programs have no <em>a priori</em> notion of data flow&#8212;a 
single logic program may run in multiple <em>modes</em>
where each mode describes, or prescribes, a pattern of data flow.
</p>

<p>
A <em>mode system</em> provides an abstract domain
for describing the flow of data in logic programs,
and an algorithm for analysing programs to <em>infer</em> the
modes of a program or to <em>check</em> the correctness of
<em>mode declarations</em> given by the programmer.
Such an analysis can provide much useful information to the compiler for
optimising the program.
In a prescriptive mode system, mode analysis is also an important part of the
semantic analysis phase of compilation (much like type analysis)
and can inform the programmer of many errors or potential errors in the
program at compile time.
We therefore believe it is an essential component of any industrial strength
logic programming system.
</p>

<p>
Our aim is to develop a strong and prescriptive mode system that is both
as precise and expressive as possible.
We believe this requires a strongly typed and purely declarative
language and so we focus on the language Mercury.
</p>


<p>
The first contribution of our work is to give a detailed description
of Mercury's existing mode system, which is based on abstract interpretation.
Although most of this system has been around for several years,
this is the first time it has been described in this level of detail.
This is also the first time the relationship of the mode system to
the formalism of abstract interpretation has been made clear.
</p>

<p>
Following that, we look at ways of extending the mode system to provide further
precision and expressiveness, and to overcome some of the limitations of the
current system.
</p>

<p>
The first of these extensions is to support a form of constrained parametric
polymorphism for modes.
This is analogous to constrained parametric polymorphic type systems such as
type classes, and adds a somewhat similar degree of expressiveness to the mode
system.
</p>

<p>
Next we look at a method for increasing the precision of the mode analysis by
keeping track of aliases between variables.
The increased precision we gain from this allows an increase in expressiveness
by allowing the use of partially instantiated data structures and more
complex uniqueness annotations on modes.
</p>

<p>
The final area we look at is an alternative approach to mode analysis using
Boolean constraints.
This allows us to design a mode system that can capture complex
mode constraints between variables and
more clearly separates the various tasks required for mode analysis.
We believe that this constraint-based system provides a good platform for
further extension of the Mercury mode system.
</p>

<p>
The work we describe has all been
implemented in the Melbourne Mercury compiler,
although only constrained parametric polymorphism has so far become part of an
official compiler release.
</p>

<li>
<strong>
<a name = "aadebug03-paper">
Idempotent I/O for safe time travel
</a>
</strong>
<br>
Zoltan Somogyi.
<em>
Proceedings of the Fifth International Workshop on Automated Debugging,
</em>
Ghent, Belgium, September 2003.
<a href = "papers/aadebug03_paper.pdf">
Available here (143K).
</a>
<p>
Debuggers for logic programming languages have traditionally had
a capability most other debuggers did not:
the ability to jump back to a previous state of the program,
effectively travelling back in time in the history of the computation.
This ``retry'' capability is very useful,
allowing programmers to examine in detail
a part of the computation that they previously stepped over.
Unfortunately, it also creates a problem:
while the debugger may be able to restore the previous values of variables,
it cannot restore the part of the program's state
that is affected by I/O operations.
If the part of the computation being jumped back over performs I/O,
then the program will perform these I/O operations twice,
which will result in unwanted effects ranging
from the benign (e.g. output appearing twice)
to the fatal (e.g. trying to close an already closed file).
<p>
We present a simple mechanism for ensuring that
every I/O action called for by the program is executed at most once,
even if the programmer asks the debugger to travel back in time
from after the action to before the action.
The overhead of this mechanism is low enough and can be controlled well enough
to make it practical to use it to debug
computations that do significant amounts of I/O.
<p>

<li>
<strong>
<a name="juliensf-hons">
Termination analysis for Mercury using convex constraints
</a>
</strong>
<br>
Julien Fischer.
<br>
<em>
Honours report,
</em>
Department of Computer Science and Software Engineering, 
The University of Melbourne, 
August 2002.
<a href = "papers/juliensf_hons.ps.gz">
Available here (143K).
</a>
<p>
This report presents a new termination analysis for Mercury that
approximates interargument size relationships using convex constraints.
These relationships are derived using an analysis based upon abstract
interpretation.
Although this analysis is more expensive than that of the existing termination
analyser, it is able to prove the termination of a larger class of predicates.
We consider how this analysis interacts with aspects of Mercury such as the
module system, declarative I/O, higher-order code and the foreign language
interface.
<p>

<li>
<strong>
<a name="conway-thesis">
Towards parallel Mercury
</a>
</strong>
<br>
Thomas Conway.
<br>
<em>
Ph.D. thesis,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
July 2002.
<a href = "papers/conway-thesis.ps.gz">
Available here (562K).
</a>
<p>
This thesis presents the foundations for extending the implementation
of the declarative logic programming language Mercury
to support the parallel execution of programs.
<p>
The new material in this thesis is in three parts.
The first part
presents an extension to the existing (sequential) execution model for Mercury
that allows programs to be executed in parallel.
Programmers can exploit this extension simply
by replacing some sequential conjunction operators
connecting independent goals with a new parallel conjunction operator.
Such changes do not change the declarative semantics of the program,
but can improve performance.
<p>
The second part of the new material presents a model
for explicit threading in Mercury,
which is useful when the programmer's goal is not efficiency
but the explicit representation of concurrent tasks
and control of their interactions.
We show how our extended execution model
supports the usual operations on threads.
We also present a new interpretation for Mercury's system for input and output
that provides an intuitive understanding of the interactions
between the I/O operations executed by the different threads of a program
or by different programs.
<p>
The final part of the new material presented in this thesis
presents a new technique for obtaining
a detailed and accurate picture of the performance of a program.
The basis of our technique is
associating a complete context with each measurement,
rather than approximating the context as conventional profilers do.
In order to make our new profiling system feasible
we have had to develop sophisticated techniques
for reducing the cost of recording complete contexts;
in order to make its output tractable,
we also had to develop techniques for dealing with
interactions between higher order constructs and recursion.
We have also developed a tool for helping programmers
(and eventually compilers) to digest the large volume of data
generated by our profiling technique.
<p>
All the ideas presented in this thesis have been implemented in
the Melbourne Mercury compiler.
<p>

<li>
<strong>
<a name="dgj-thesis-final">
Expressive type systems for logic programming languages
</a>
</strong>
<br>
David Jeffery.
<br>
<em>
Ph.D. thesis,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
February 2002.
<a href = "papers/dgj-thesis-final.ps.gz">
Available here (370K).
</a>
<p>
The aim of this thesis is the design of a type system
for an industrial strength logic programming language.
The type system we describe has been implemented
for the Mercury programming language, in the Melbourne Mercury compiler.
<p>
We begin by presenting a simple higher order extension
of the Mycroft-O'Keefe type system.
We then use this type system as a basis for two significant extensions.
<p>
The first extension is the adoption of a type class system similar to that
found in some modern functional languages
in the context of higher order logic programming.
We give a set of typing rules which
both provide a formal definition of type correctness
and define the source-to-source transformation we have used
to implement type classes.
This transformation is simple and effective,
and can be easily shown to preserve Mercury's
mode, determinism and uniqueness correctness properties.
<p>
The second extension is to allow existentially quantified type variables
in the types of function symbols and of predicates.
This represents the most significant contribution of this thesis.
We then formally define the type system that results from the combination
of both type classes and existential quantification of type variables.
The two type system extensions are quite orthogonal.
As a result, the definition of type correctness in the combined system
is a fairly simple combination of the definitions for the individual systems.
However, the mechanisms contributed by the two systems combine synergistically;
the resulting type system is extremely expressive.
<p>
We then show how the type system we have designed allows the programmer
to take advantage of many object oriented design techniques.
We give an in depth analysis of object oriented design
and isolate the mechanisms which are likely to result
in reusable and maintainable software systems.
We show that our type system allows the programmer
to directly express these kinds of designs
and discourages the use of the kinds of object oriented designs
which reduce maintainability
by introducing unnecessary implementation dependencies.
<p>
We show that these principles apply in a direct and simple manner
to the modelling of component interfaces
as supported by modern component frameworks such as CORBA.
We present MCORBA, an implementation of a CORBA binding for Mercury.
This interface is bi-directional,
allowing the programmer to write CORBA components in Mercury
and to use existing CORBA components from within Mercury programs.
<p>

<li>
<strong>
<a name="p33-overton">
Constraint-based mode analysis of Mercury
</a>
</strong>
<br>
David Overton, Zoltan Somogyi and Peter Stuckey
<br>
<em>
Proceedings of the Fourth International Conference on
Principles and Practice of Declarative Programming,
</em>
Pittsburgh, Pennsylvania, October 2002, pages 109-120.
<a href = "papers/p33-overton.ps.gz">
Available here (188K).
</a>
<p>
Recent logic programming languages, such as Mercury and HAL,
require type, mode and determinism
declarations for predicates. This information allows the generation of
efficient target code and the detection of many errors at compile-time.
Unfortunately, mode checking in such languages is difficult. One of the main
reasons is that, for each predicate mode declaration,
the compiler is required to decide
which parts of the procedure bind which variables,
and how conjuncts in the predicate definition should be re-ordered
to enforce this behaviour.
Current mode checking systems limit the possible modes that may be used
because they do not keep track of aliasing information,
and have only a limited ability to infer modes,
since inference does not perform reordering.
In this paper we develop a mode inference system for Mercury
based on mapping each predicate to a system of Boolean constraints
that describe where its variables can be produced.
This allows us handle programs that are not supported by the existing system.
<p>

<li>
<strong>
<a name="p81-somogyi">
Using the heap to eliminate stack accesses
</a>
</strong>
<br>
Zoltan Somogyi and Peter Stuckey
<br>
<em>
Proceedings of the Fourth International Conference on
Principles and Practice of Declarative Programming,
</em>
Pittsburgh, Pennsylvania, October 2002, pages 121-132.
<a href = "papers/p81-somogyi.ps.gz">
Available here (190K).
</a>
<p>
The value of a variable is often given by a field of a heap cell,
and frequently the program will pick up the values of several variables
from different fields of the same heap cell.
By keeping some of these variables out of the stack frame,
and accessing them in their original locations on the heap instead,
we can reduce the number of loads from and stores to the stack
at the cost of introducing a smaller number of loads from the heap.
We present an algorithm that finds the optimal set of variables
to access via a heap cell instead of a stack slot,
and transforms the code of the program accordingly.
We have implemented this optimization in the Mercury compiler,
and our measurements show that it can reduce program runtimes by up to 12%
while at the same time reducing program size.
The optimization is straightforward to apply to Mercury
and to other languages with immutable data structures;
its adaptation to languages with destructive assignment
would require the compiler to perform mutability analysis.
<p>

<li>
<strong>
<a name="high_level_gc">
Accurate garbage collection in an uncooperative environment
</a>
</strong>
<br>
Fergus Henderson
<br>
<em>
Proceedings of the 2002 International Symposium on Memory Management,
</em>
Berlin, Germany, June 2002, pages 150-156.
<a href = "papers/high_level_gc.ps.gz">
Available here (83K).
</a>
<p>
Previous attempts at garbage collection in uncooperative environments
have generally used conservative or mostly-conservative approaches.
We describe a technique for doing fully type-accurate
garbage collection in an uncooperative environment,
using a ``shadow stack'' to link structs of pointer-containing variables,
together with the data or code needed to trace them.
We have implemented this in the Mercury compiler, which generates C code,
and present preliminary performance data on the overheads of this technique.
We also show how this technique can be extended to handle multithreaded
applications.
<p>

<li>
<strong>
<a name="mercury_to_clr">
Compiling Mercury to the .NET Common Language Runtime
</a>
</strong>
<br>
Tyson Dowd, Fergus Henderson, and Peter Ross
<br>
<em>
BABEL'01 First International Workshop on
Multi-Language Infrastructure and Interoperability,
</em>
Firenze, Italy, September 2001.  Preliminary Proceedings pages 70-85.
To appear in Electronic Notes in Theoretical Computer Science 59.1.
<a href = "papers/mercury_to_clr.ps.gz">
Available here (93K).
</a>
<p>
The .NET Common Language Runtime (CLR) offers a new opportunity to
experiment with multi-language interoperation, and provides a relatively
rare chance to explore deep interoperation of a wide range of
programming language paradigms.
This article describes how Mercury is compiled to the CLR.
We describe the problems we have
encountered with generating code for the CLR,
give some preliminary benchmark results,
and suggest some possible improvements to the CLR
regarding separate compilation, verifiability, tail calls, and efficiency.
<p>

<li>
<strong>
<a name="hlc_cc">
Compiling Mercury to high-level C code
</a>
</strong>
<br>
Fergus Henderson and Zoltan Somogyi
<br>
<em>
Proceedings of the 2002 International Conference on Compiler Construction
</em>
Grenoble, France, April 2002.
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href = "papers/hlc_cc.ps.gz">Available here (67K)</a>.
<p>
Many logic programming implementations compile to C,
but they compile to very low-level C, and thus discard many
of the advantages of compiling to a high-level language.
We describe an alternative approach to compiling logic
programs to C, based on continuation passing, that we have used
in a new back-end for the Mercury compiler.
The new approach compiles to much higher-level C code,
which means the compiler back-end and run-time system
can be considerably simpler.
<p>
We present a formal schema for the transformation,
and give benchmark results which show that this approach delivers
performance that is more than competitive
with the fastest previous implementation,
with greater simplicity and better portability and interoperability.
<p>
The approach we describe can also be used
for compiling to other target languages,
such as IL (the Microsoft .NET intermediate language).
<p>
The benchmark data on which the performance evaluation section of this paper
is based is
<a href = "papers/hlc_cc_perf.tar.gz">available here (9.7M)</a>.
<p>

<li>
<strong>
<a name="mu_01_24">
Deep profiling:
engineering a profiler for a declarative programming language
</a>
</strong>
<br>
Thomas C. Conway and Zoltan Somogyi
<br>
<em>
Technical Report 2001/24,
</em>
Department of Computer Science, University of Melbourne,
Melbourne, Australia, July 2001, 61 pages.
<a href = "papers/mu_01_24.ps.gz">
Available here (207K).
</a>
<p>
Declarative programs differ from imperative programs in several respects,
the main ones being their heavy use of recursion,
of various forms of polymorphism, and of higher order.
Existing profilers tend not to produce very useful information
in the presence of these constructs.
We present a new profiling technique we call \emph{deep profiling}
that yields detailed and useful information about programs
even in the presence of these constructs,
information that is significantly richer
than the output of other profilers.
<p>
The heart of deep profiling is a source-to-source transformation.
We have implemented this transformation and its associated infrastructure
in the compiler for Mercury, a purely declarative logic programming language.
While our measurements of this implementation
show that deep profiling has slightly greater overhead
than some other profiling techniques,
the wealth of information it provides
makes this extra overhead worthwhile.
The deep profiling algorithms themselves
are applicable to most other language styles,
including imperative, object-oriented, and functional languages.
<p>

<li>
<strong>
<a name="iclp2001_ctgc">
Practical aspects for a working compile time garbage collection system
for Mercury
</a>
</strong>
<br>
Nancy Mazur, Peter Ross, Gerda Janssens and Maurice Bruynooghe
<br>
<em>
Proceedings of ICLP 2001 - Seventeenth International Conference on 
Logic Programming
</em>,
Paphos, Cyprus, November 2001. Lecture Notes in Computer Science 2237, 
Springer Verlag, 
Pages 105-119
&copy;
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href = "papers/iclp2001_ctgc.ps.gz">
Available here (84K).
</a>
<p>
Compile-time garbage collection (CTGC) 
is still a very uncommon feature within
compilers. 
In previous work we have developed a compile-time structure
reuse system for Mercury, a logic programming language. 
This system 
indicates which datastructures can safely be reused at run-time. 
As preliminary experiments were promising, we 
have continued this work and have now a 
working and well performing near-to-ship
CTGC-system built into the Melbourne Mercury
Compiler (MMC). 
<br>
In this paper we present the multiple design decisions leading to this
system, we report the results of using CTGC 
for a set of benchmarks, including a
real-world program, and finally we discuss further
possible improvements. 
Benchmarks show substantial memory savings and a noticeable reduction
in execution time. 
<p>

<li>
<strong>
<a name="bta_higher_order">
Binding-time analysis by constraint solving: a modular and
higher-order approach for Mercury
</a>
</strong>
<br>
Wim Vanhoof
<br>
<em>
Proceedings of the Seventh International Conference on Logic for
Programming and Automated Reasoning
</em>,
Reunion Island, France, November 2000.
Lecture Notes in Computer Science 1955,
Springer Verlag, 
Pages 399-416
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/bta_higher_order.ps.gz">Available here (106K)</a>.
<p>
In this paper we present a binding-time analysis for the logic
programming language Mercury. Binding-time analysis is a key analysis
needed to perform off-line program specialisation.  Our analysis deals
with the higher-order aspects of Mercury, and is formulated by means of
constraint normalisation. This allows (at least part of) the analysis to
be performed on a modular basis.
<p>

<li>
<strong>
<a name="memory_reuse_analysis">
A module based analysis for memory reuse in Mercury
</a>
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe
<br>
<em>
Proceedings of the First International Conference on Computational Logic 
</em>,
London, United Kingdom, July 2000.
Lecture Notes in Artificial Intelligence,
Springer Verlag, 
Pages 1255-1269
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/memory_reuse_analysis.ps.gz">Available here (93K)</a>.
<p>
In previous work Bruynooghe, Janssens and K&aring;gedal developed a
live-structure analysis for Mercury which detects memory cells available
for reuse.  Seperate compilation of modules is an essential ingredient
of a language such as Mercury which supports programming in the large.
Hence, to be practical, a live-structure analysis also has to be module
based.  This paper develops a modular live-structure analysis and
extends it with a modular reuse analysis.  It also describes preliminary
results obtained with a first prototype of the module based analysis.
<p>

<li>
<strong>
<a name="tail_lopstr_lncs">
Making Mercury programs tail recursive
</a>
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi
<br>
<em>
Proceedings of the Ninth International Workshop on Logic-based Program
Synthesis and Transformation</em>,
Venice, Italy, September 1999.
To appear in Lecture Notes in Computer Science,
Springer Verlag, 
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/tail_lopstr_lncs.ps.gz">Available here (84K)</a>.
<p>
We present two optimizations for making Mercury programs tail recursive.
Both operate by taking computations that occur after a recursive call
and moving them before the recursive call, modifying them as necessary.
The first optimization moves calls to associative predicates;
it is a pure source to source transformation.
The second optimization moves construction unifications;
it required extensions to the mode system (to record aliases)
and to the parameter passing convention
(to allow arguments to be returned in memory).
The two optimizations are designed to work together,
and can make a large class of programs tail recursive.
<p>
The raw data on which the evaluation is based
is available as a <a href = "papers/tail_data.tar.gz">5 Kb tar file</a>.
<p>

<li>
<strong>
<a name="update">
State update transformation
</a>
</strong>
<br>
Peter Ross and Zoltan Somogyi
<br>
<em>
</em>
<a href="papers/update.ps.gz">Available here (57K)</a>.
<p>
Recursive predicates frequently generate some state
which is updated after the recursive call.
We present a source to source transformation
which can move the state update before the recursive call,
thus helping to make the predicate tail recursive,
and report on its implementation in the Mercury compiler.
<p>

<li>
<strong>
<a name="purity">
Using impurity to create declarative interfaces in Mercury
</a>
</strong>
<br>
Tyson Dowd, Peter Schachte, Fergus Henderson and Zoltan Somogyi
<br>
<em>Technical Report 2000/17</em>,
Department of Computer Science, University of Melbourne,
Melbourne, Australia, April 2000, 10 pages.
<a href="papers/purity.ps.gz">Available here (52K)</a>.
<p>
The logic/functional language Mercury
allows the programmer to annotate predicates and
functions to mark impure predicates, allowing
impure code to be safely integrated into a
declarative language.
<p>
By using purity declarations with the foreign language
interface, programmers can take advantage of many of the
features of a high level programming language while
writing imperative code to interface with existing
imperative libraries.
<p>
This paper outlines the purity system in Mercury and
how it affects operational semantics,
compares this purity system with other approaches to declaring
impurity in a pure language,
and gives an extended example of how impurity and foreign language
interfaces can work together to simplify the chore of writing
declarative interfaces to libraries.
<p>

<li>
<strong>
<a name="liveness">
Towards memory reuse for Mercury
</a>
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe
<br>
<em>
Proceedings of the International Workshop on Implementation of
Declarative Languages
</em>,
Paris, France, October 1999
<a href="papers/liveness.ps.gz">Available here (61K)</a>.
<p>
While Mercury allows destructive input/unique output modes which direct
the compiler to reuse memory, use of these modes can be cumbersome for
the programmer.  In most situations, it would be nicer if the programmer
didn't have to worry about the details of memory management.

The paper briefly reports on some experiments with a prototype analyser
which aims at detecting memory available for reuse. The prototype is
based on the live-structure analysis developed by us for logic programs
extended with declarations.

Yet the major contribution of this paper consists of the development of
the principles of a module based analysis which are essential for the
analysis of large Mercury programs with code distributed over many
modules.
<p>

<li>
<strong>
<a name="bta">
Binding-time analysis for Mercury
</a>
</strong>
<br>
Wim Vanhoof and Maurice Bruynooghe
<br>
<em>
Proceedings of the Sixteenth International Conference on Logic Programming
</em>,
Las Cruces, New Mexico, November 1999, pages 500-514
<a href="papers/bta.ps.gz">Available here (76K)</a>.
<p>
In this paper, we describe a binding-time analysis (BTA) for a
statically typed and strongly moded pure logic programming language, in
casu Mercury.  Binding-time analysis is the key concept in achieving
off-line program specialisation: the analysis starts from a description
of the program's input available for specialisation, and propagates this
information throughout the program, deriving directives for when and how
to perform specialisation.  Exploiting the possibilities offered by
Mercury's strong type and mode system, we present a completely automatic
BTA dealing with partially static binding-times.
<p>

<li>
<strong>
<a name="debugger_wlpe99">
The implementation technology of the Mercury debugger
</a>
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
<br>
<em>
Proceedings of the Tenth Workshop on Logic Programming Environments
</em>,
Las Cruces, New Mexico, November 1999, pages 35-49.
<a href="papers/debugger_wlpe99.ps.gz">Available here (66K)</a>.
<p>

Every programming language needs a debugger.
Mercury now has three debuggers:
a simple procedural debugger
similar to the tracing systems of Prolog implementations,
a prototype declarative debugger,
and a debugger based on the idea of automatic trace analysis.
In this paper, we present the shared infrastructure
that underlies the three debuggers,
and describe the implementation of the procedural debugger.
We give our reasons for each of our main design decisions,
and show how several of these decisions are rooted in our experience
with the debugging of large programs working with large data structures.
<p>

<li>
<strong>
<a name="tail_lopstr">
Making Mercury programs tail recursive (extended abstract)
</a>
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi.
<br>
<em>
Pre-Proceedings of the Ninth International Workshop on Logic-based Program
Synthesis and Transformation
</em>,
Venice, Italy, September 1999, pages 107-118.
<a href="papers/tail_lopstr.ps.gz">Available here (62K)</a>.
<p>

This paper has been superceded by the LNCS version.
<p>

<li>
<strong>
<a name="rtti_ppdp">
Run time type information in Mercury
</a>
</strong>
<br>
Tyson Dowd, Zoltan Somogyi, Fergus Henderson, Thomas Conway and David Jeffery.
<br>
<em>
Proceedings of the International Conference
on the Principles and Practice of Declarative Programming
</em>,
Paris, France, September/October 1999,
Lecture Notes in Computer Science 1702, 
Springer Verlag, 
Pages 224-243,
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/rtti_ppdp.ps.gz">Available here (75K)</a>.
<p>

The logic/functional language Mercury
uses a strong, mostly static type system
based on polymorphic many-sorted logic.
For efficiency,
the Mercury compiler uses type specific representations of terms,
and implements polymorphic operations such as unifications
via generic code invoked with descriptions of the actual types of the operands.
These descriptions, which consist of automatically generated data and code,
are the main components of the Mercury runtime type information (RTTI) system.
We have used this system to implement several extensions of the Mercury system,
including an escape mechanism from static type checking,
generic input and output facilities, a debugger, and automatic memoization,
and we are in the process of using it
for an accurate, native garbage collector.
We give detailed information
on the implementation and uses of the Mercury RTTI system
as well as measurements of the space costs of the system.
<p>
The raw data on which the evaluation is based
is available as a <a href = "papers/rtti_data.tar.gz">70 Kb tar file</a>
<p>

<li>
<strong>
<a name="stayl_hons">
Optimization of Mercury programs
</a>
</strong>
<br>
Simon Taylor.
<br>
<em>
Honours report.
</em>
Department of Computer Science, University of Melbourne, November 1998.
<a href = "papers/stayl_hons.ps.gz">
Available here (120K).
</a>
<p>

This paper describes the implementation of several of the high-level
optimization passes of the Mercury compiler, including deforestation,
type specialization, constraint propagation and structure reuse.
<p>

<li>
<strong>
<a name="mcorba_padl99">
MCORBA: A CORBA Binding for Mercury
</a>
</strong>
<br>
David Jeffery, Tyson Dowd and Zoltan Somogyi.
<br>
In <em>
Proceedings of the First International Workshop
on Practical Aspects of Declarative Languages
</em>,
San Antonio, Texas,
January 1999, 
Lecture Notes in Computer Science 1551, 
Springer Verlag, 
Pages 211-227,
&copy; 
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<a href="papers/mcorba_padl99.ps.gz">Available here (65K)</a>.
<p>

MCORBA is a binding to the CORBA distributed object framework
for the purely declarative logic/functional language Mercury.
The binding preserves the referential transparency of the language,
and has several advantages
over similar bindings for other strongly typed declarative languages.
As far as we know, it is the first such binding to be bidirectional;
it allows a Mercury program both to operate upon CORBA components
and to provide services to other CORBA components.
Whereas the Haskell binding for COM
maps COM interfaces onto Haskell types,
MCORBA maps CORBA interfaces onto Mercury type classes.
Our approach simplifies the mapping,
makes the implementation of CORBA's interface inheritance straightforward,
and makes it trivial for programmers to provide
several different implementations of the same interface.
It uses existential types to model the operation
of asking CORBA for an object that satisfies a given interface
but whose representation is unknown.
<p>

<li>
<strong>
<a name="mu_98_13">
Type classes in Mercury
</a>
</strong>
<br>
David Jeffery, Fergus Henderson and Zoltan Somogyi.
<br>
<em>
Technical Report 98/13,
</em>
Department of Computer Science, University of Melbourne,
Melbourne, Australia, September 1998, 22 pages.
<a href = "papers/mu_98_13.ps.gz">
Available here (82K).
</a>
<p>

In this paper, we explain how we have extended Mercury's type system 
to include support for type classes.
We give a formal semantics for this extension to our type system,
adapting the typing rules used in functional languages
to the differing demands of logic programming languages.
We show that type classes integrate very nicely
with Mercury's mode, uniqueness and determinism systems,
and describe how our implementation works.
<p>

<li>
<strong>
<a name="sas97">
Termination analysis for Mercury
</a>
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
<br>
<em>
Proceedings of the Fourth Static Analysis Symposium
</em>,
Paris, France, September 1997, pages 157-171.
<a href = "papers/sas97.ps.gz">available here (75K)</a>.
A longer version of the paper appeared as
Technical Report 97/9,
Department of Computer Science, University of Melbourne,
Melbourne, Australia, July 1997, 25 pages.
it is <a href = "papers/mu_97_09.ps.gz">available here (99K)</a>.
<p>

This paper presents the algorithms of the Mercury termination analyser,
discusses how real-world aspects of the language
such as modules, higher-order features, foreign language code,
and declarative input/output can be handled,
and evaluates the performance of the analyser
both on a set of standard test programs and on the Mercury compiler itself.
<p>
The raw data on which the evaluation is based is available
as a <a href = "papers/termination_data.tar.gz">5.2 Mb tar file</a>.
<p>

<li>
<strong>
<a name="jicslpw">
Status of the Mercury system
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<br>
<em>
Proceedings of the JICSLP '96 Workshop on Parallelism and
Implementation Technology for (Constraint) Logic Programming Languages,
</em>
Bonn, Germany, September 1996, pages 207-218.
<a href = "papers/jicslpw.ps.gz">Available here (46K)</a>.
<p>

<li>
<strong>
<a name="jlp">
The execution algorithm of Mercury:
an efficient purely declarative logic programming language
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Journal of Logic Programming,
</em>
volume 29, number 1-3, October-December 1996, pages 17-64.
<a href = "papers/jlp.ps.gz">Available here (138K)</a>.
<br>
Elsevier owns the copyright of this paper;
it is made available here by their permission.
<p>

This paper contains a brief overview of the Mercury language, and a
reasonably detailed overview of the implementation technology used in
the Mercury compiler.  It describes the abstract machine that the
compiler generates code for.  (Our other papers listed below go
into more detail on exactly how the code is generated, and on how
the abstract machine instructions are implemented as C or GNU C code.)
<p>
The raw data on which the evaluation is based
is available on our <a href = "./benchmarks.html">benchmarking page</a>.
<p>

<li>
<strong>
<a name="acsc96">
Determinism analysis in the Mercury compiler
</a>
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<br>
<em>
Proceedings of the Australian Computer Science Conference,
</em>
Melbourne, Australia, January 1996, pages 337-346.
<a href = "papers/acsc96.ps.gz">Available here (78K)</a>.
A longer version of the paper is
<a href = "papers/detism.ps.gz">available here (76K)</a>.
<p>

This paper discusses Mercury's determinism system in detail, including
the algorithms for switch detection, deep indexing, determinism
inference, and determinism checking.
<p>

<li>
<strong>
<a name="code_gen_mit">
Code generation for Mercury
</a>
</strong>
<br>
Thomas Conway, Fergus Henderson, and Zoltan Somogyi.
<br>
<em>
Proceedings of the 1995 International Symposium on Logic Programming,
</em>
Portland, Oregon, December 1995, pages 242-256.
<a href = "papers/code_gen_mit.ps.gz">Available here (68K)</a>.
<p>

This paper describes the structure of the Mercury compiler,
its calling conventions,
and the algorithms it uses in generating code.
These algorithms include lazy code generation
and a novel way of handling nested disjunctions.
<p>

<li>
<strong>
<a name="mercury_to_c">
Compiling logic programs to C
using GNU C as a portable assembler
</a>
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<br>
<em>
Proceedings of the ILPS '95 Postconference Workshop on
Sequential Implementation Technologies for Logic Programming Languages.
</em>
Portland, Oregon, December 1995.
<a href = "papers/mercury_to_c.ps.gz">Available here (65K)</a>.
<p>

This paper discusses the merits of using C, and in particular GNU C,
as an intermediate target language for the compilation of logic programs,
and describes the approach we have taken in the implementation of Mercury.
<p>

<li>
<strong>
<a name="acsc95">
Mercury: an efficient purely declarative logic programming language
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Proceedings of the Australian Computer Science Conference,
</em>
Glenelg, Australia, February 1995, pages 499-512.
<a href = "papers/acsc95.ps.gz">Available here (85K)</a>.
<p>

An overview paper.
<p>

<li>
<strong>
<a name="ilps94w">
The implementation of Mercury:
an efficient purely declarative logic programming language
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Proceedings of the ILPS '94 Postconference Workshop on
Implementation Techniques for Logic Programming Languages,
</em>
Syracuse, New York, November 1994.
<a href = "papers/ilps94w.ps.gz">Available here (96K)</a>.
<p>

The first paper on Mercury. It is superseded by the paper
in the Journal of Logic Programming.
<p>

<li>
<strong>
<a name="conway_hons">
Code generation for Mercury
</a>
</strong>
<br>
Thomas Conway.
<br>
<em>
Honours report.
</em>
Department of Computer Science, University of Melbourne, November 1994.
<a href = "papers/conway_hons.ps.gz">Available here (188K)</a>.
<p>

This is the first paper on the code generator.
Warning: several aspects of the code generator have changed
since this paper was written.
Some of these are documented in the version in the ILPS 95 proceedings.

</ul>

<hr>

<h2><a name="related">Related Papers</a></h2>

<a name="mu_97_23">
This paper gives an introduction to automatic termination analysis.
It surveys termination analysis of logic programs and provides an
overview of the important concepts involved in automatic termination
analysis.
</a>
<p>

<ul>
<li>
<strong>
Termination analysis for logic programs
</strong>
<br>
Chris Speirs.
<br>
<em>
Technical Report 97/23,
</em>
Department of Computer Science, University of Melbourne, October 1997.
<a href = "papers/mu_97_23.ps.gz">
Available here (67K).
</a>
 
</ul>

<p>
<a name="vision">
This paper outlines the features that we believe to be important
in a modern logic programming language:
</a>
<p>

<ul>
<li>
<strong>
Logic programming for the real world
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway and Richard O'Keefe.
<br>
<em>
Proceedings of the ILPS '95 Postconference Workshop on
Visions for the Future of Logic Programming,
</em>
Portland, Oregon, December 1995.
<a href = "papers/vision.ps.gz">
Available here (59K).
</a>
<p>

</ul>

<a name="iclp87">
The mode system and the uniqueness system of Mercury
are based on the following papers:
</a>
<p>

<ul>

<li>
<strong>
A system of precise modes for logic programs
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
Proceedings of the Fourth International Conference on Logic Programming,
</em>
Melbourne, Australia, May 1987, pages 769-787.
<a href = "http://www.cs.mu.oz.au/~zs/papers/iclp87.ps.gz">
Available here (40K).
</a>
<p>

<li>
<strong>
<a name="fjh_hons_thesis">
Strong modes can change the world!
</a>
</strong>
<br>
Fergus Henderson.
<br>
<em>
Honours Report.
</em>
Department of Computer Science, University of Melbourne, November 1992.
<a href = "http://www.cs.mu.oz.au/~fjh/papers/hons_thesis.ps.gz">
Available here (114K).
</a>
<p>

</ul>

<a name="mu_96_45">
The following paper describes the method used to express database 
transactions and updates that is used in the Mercury ODBC database
interface.
</a>

The same kind of approach is also used in
the Mercury interface to the Aditi deductive
database system (see the "Aditi deductive database interface"
section in Mercury Language Reference Manual listed under 
"Implementation dependent pragmas" in the "Pragmas" chapter).

<p>
<ul>

<li>
<strong>
Database transactions in a purely declarative logic programming language
</strong>
<br>
David B. Kemp, Thomas Conway, Evan Harris, Fergus Henderson,
Kotagiri Ramamohanarao and Zoltan Somogyi.
<br>
<em>
Technical Report 96/45
</em>
Department of Computer Science, University of Melbourne, December 1996.
<a href = "http://www.cs.mu.OZ.AU/publications/tr_db/mu_96_45.ps.gz">
Available here (58K)
</a>
<a href = "http://www.cs.mu.OZ.AU/publications/tr_db/mu_96_45_cover.ps.gz">
with cover page.
</a>

<a name="tr90-2">
The following paper is also relevant to the Aditi interface mentioned above.
It describes a source-to-source transformation implemented in the
Mercury compiler.
</a>

<li>
<strong>
Right-, left-, and multi-linear rule transformations that maintain
context information
</strong>
<br>
David B. Kemp and Kotagiri Ramamohanarao and Zoltan Somogyi. 
<br>
<em>
Technical Report 90/2
</em>
Department of Computer Science, University of Melbourne, October 1997.
<a href = "papers/tr90-2.ps.gz">
Available here (48K).
</a>
Note that this paper incorrectly claims that
the context transformation can be applied to
mixed-linear predicates containing pseudo-left-linear rules
as well as other linear rules.  
It is corrected in David Kemp's thesis,
<a href = "http://www.cs.mu.oz.au/~kemp/papers/thesis.ps.gz">
available here (560K).
</a>

</ul>

<hr>

<h2><a name="presentations">Presentations on Mercury</a></h2>

<ul>

<li>
<strong>
<a name = "papers.html#aadebug03-talk">
Idempotent I/O for safe time travel
</a>
</strong>
<br>
Zoltan Somogyi.
<em>
Invited talk presented at
the Fifth International Workshop on Automated Debugging,
</em>
Ghent, Belgium, September 2003.
<a href = "papers/aadebug03_talk.pdf">
Available here (20K).
</a>
<p>

<li>
<strong>
<a name = "papers.html#ppdp02mode-talk">
Constraint-based mode analysis of Mercury
</a>
</strong>
<br>
David Overton, Zoltan Somogyi and Peter J. Stuckey.
<em>
Talk presented at Fourth International Conference
on Principles and Practice of Declarative Programming.
</em>
Pittsburgh, Pennsylvania, October 2002.
<a href = "papers/ppdp02_mode.pdf">
Available here (117K).
</a>
<p>

<li>
<strong>
<a name = "papers.html#ppdp02stack-talk">
Using the heap to eliminate stack accesses
</a>
</strong>
<br>
Zoltan Somogyi and Peter J. Stuckey.
<em>
Talk presented at Fourth International Conference
on Principles and Practice of Declarative Programming.
</em>
Pittsburgh, Pennsylvania, October 2002.
<a href = "papers/ppdp02_stack.ps">
Available here (26K).
</a>
<p>

<li>
<strong>
<a name="sas_talk">
Termination analysis for Mercury
</a>
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
<br>
<em>
Talk presented at the Fourth Static Analysis Symposium.
</em>
Paris, France, September 1997.
<a href = "papers/sas_talk.ps.gz">
Available here (6K).
</a>
<p>

<li>
<strong>
<a name="unif">
Unification in Mercury
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
Invited talk presented at the Eighth Benelux Workshop on Logic Programming.
</em>
Louvain-la-Neuve, Belgium, September 1996.
<a href = "papers/unif.ps.gz">
Available here (12K).
</a>
<p>

<li>
<strong>
<a name="jicslp_talk">
The design and implementation of Mercury
</a>
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
<br>
<em>
Tutorial presented at the Joint International
Conference and Symposium on Logic Programming.
</em>
Bonn, Germany, September 1996.
<a href = "papers/jicslp_talk.ps.gz">
Available here (18K).
</a>
<p>

<li>
<strong>
<a name="jicslpw_talk">
Status of the Mercury system
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<br>
<em>
Presented at the JICSLP '96 Workshop on Parallelism and
Implementation Technology for (Constraint) Logic Programming Languages,
</em>
Bonn, Germany, September 1996.
<a href = "papers/jicslpw_talk.ps.gz">
Available here (5K).
</a>
<p>

<li>
<strong>
<a name="acsc95_slides">
Mercury:
an efficient purely declarative logic programming language
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Presented at the Eighteenth Australasian Computer Science Conference,
</em>
Adelaide, South Australia, February 1995.
<a href = "papers/acsc95_slides.ps.gz">
Available here (33K).
</a>
<p>

<li>
<strong>
<a name="257_1999">
Lecture notes for the expanded Mercury segment of the subject
433-257 Frontiers of Computer Science, given in 1999
(whereas the segment in 1997 had four lectures, in 1999 it had six)
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<a href = "papers/257_1999.ps.gz">
Available here (40K).
</a>
<p>

<li>
<strong>
<a name="257">
Lecture notes for the Mercury segment of the subject
433-257 Frontiers of Computer Science, given in 1997
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<a href = "papers/257.ps.gz">
Available here (21K).
</a>
<p>

<li>
<strong>
<a name="247">
Lecture notes for the Mercury segment of the subject
433-247 Frontiers of Computer Science, given in 1995
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<a href = "papers/247.ps.gz">
Available here (21K).
</a>
<p>

<li>
<strong>
<a name="dgj-talk">
Type classes for logic programming languages, given in March 1998
</a>
</strong>
<br>
David Jeffery.
<br>
<a href = "papers/dgj-talk.ps.gz">
Available here (30K).
</a>
<p>

<li>
<strong>
<a name="rtti_talk_98">
Runtime type information in Mercury, given in March 1998
</a>
</strong>
<br>
Tyson Dowd.
<br>
<a href = "papers/rtti_talk_98.ps.gz">
Available here (48K).
</a>
<p>

</ul>

<p>
<hr>
<p>

All these papers and presentations are for A4 paper.
Unfortunately, we cannot generate US paper size versions.

<p>
